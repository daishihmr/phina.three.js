{"version":3,"sources":["Mesh.js","MotionController.js","Object3D.js","SkinnedMesh.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"phina.three.js","sourcesContent":["phina.namespace(function() {\r\n\r\n  phina.define(\"phina.three.Mesh\", {\r\n    superClass: \"phina.three.Object3D\",\r\n\r\n    colliders: null,\r\n\r\n    init: function(options) {\r\n      if (typeof(options.$t) == \"string\") {\r\n        this.assetName = options.$t;\r\n        const orig = phina.asset.AssetManager.get(\"mesh\", this.assetName);\r\n\r\n        options.$t = orig.clone();\r\n        if (options.$t) {\r\n          this.colliders = orig.colliders.map((collider) => {\r\n            collider = collider.clone();\r\n            options.$t.add(collider);\r\n            return collider;\r\n          });\r\n        } else {\r\n          throw new Error(\"Mesh Asset \" + this.assetName + \" not found\");\r\n        }\r\n      } else {\r\n        this.colliders = [];\r\n      }\r\n\r\n      options = ({}).$safe(options, {});\r\n\r\n      this.superInit(options);\r\n\r\n      this.colliders.forEach((collider) => {\r\n        collider.visible = false;\r\n      });\r\n    },\r\n\r\n  });\r\n\r\n  const matrix = new THREE.Matrix4();\r\n  matrix.makeRotationFromEuler(new THREE.Euler(Math.PI * 0.5, Math.PI, 0));\r\n\r\n  phina.define(\"phina.three.MeshAssetLoader\", {\r\n    superClass: \"phina.asset.Asset\",\r\n\r\n    _static: {\r\n      materialCache: {},\r\n    },\r\n\r\n    init: function() {\r\n      this.superInit();\r\n    },\r\n\r\n    _load: function(resolve) {\r\n      const loader = new THREE.ObjectLoader();\r\n      loader.load(this.src, loadedObject => {\r\n        let mesh = null;\r\n        const colliders = [];\r\n\r\n        loadedObject.traverse(child => {\r\n          if (child.isMesh) {\r\n\r\n            if (!child.name.startsWith(\"collider.\")) {\r\n              // three.jsエクスポータのバグ？\r\n              child.geometry.applyMatrix(matrix);\r\n              mesh = child;\r\n            } else {\r\n              child.material.wireframe = true;\r\n              colliders.push(child);\r\n            }\r\n          }\r\n\r\n        });\r\n\r\n        if (mesh) {\r\n          mesh.colliders = colliders;\r\n          resolve(mesh);\r\n        }\r\n      });\r\n    },\r\n  });\r\n  phina.asset.AssetLoader.register(\"mesh\", (key, path) => phina.three.MeshAssetLoader().load(path));\r\n\r\n});","phina.namespace(function() {\r\n\r\n  phina.define(\"phina.three.MotionController\", {\r\n    superClass: \"phina.accessory.Accessory\",\r\n\r\n    _beforeMotion: null,\r\n    _currentMotion: null,\r\n\r\n    _beforeAction: null,\r\n    _currentAction: null,\r\n\r\n    transitionTweener: null,\r\n\r\n    init: function() {\r\n      this.superInit();\r\n\r\n      this.on(\"attached\", e => {\r\n        this.transitionTweener = phina.accessory.Tweener().attachTo(this.target);\r\n        this.target._transitionWeightBefore = 0;\r\n        this.target._transitionWeightCurrent = 0;\r\n\r\n        this.target.$t.mixer.addEventListener(\"finished\", (e) => {\r\n          if (this._currentMotion) this._currentMotion.flare(\"finished\");\r\n        });\r\n        this.target.$t.mixer.addEventListener(\"loop\", (e) => {\r\n          if (this._currentMotion) this._currentMotion.flare(\"entered\");\r\n        });\r\n      });\r\n    },\r\n\r\n    switchMotion: function(newMotion, duration) {\r\n      if (this._currentMotion === newMotion) return;\r\n\r\n      if (this._beforeAction) {\r\n        this._beforeAction.stop();\r\n      }\r\n\r\n      this._beforeMotion = this._currentMotion;\r\n      this._beforeAction = this._currentAction;\r\n\r\n      this._currentMotion = newMotion;\r\n\r\n      if (newMotion._action == null) {\r\n        newMotion._action = this.target.$t.mixer.clipAction(newMotion._clip);\r\n        if (newMotion.loop) {\r\n          newMotion._action.setLoop(THREE.LoopRepeat);\r\n        } else {\r\n          newMotion._action.setLoop(THREE.LoopOnce);\r\n          newMotion._action.clampWhenFinished = true;\r\n        }\r\n      }\r\n\r\n      this._currentAction = newMotion._action;\r\n      this._currentAction.stop();\r\n      this._currentAction.play();\r\n      this._currentAction.setEffectiveWeight(0);\r\n\r\n      if (duration) {\r\n        this.transitionTweener\r\n          .clear()\r\n          .set({\r\n            _transitionWeightBefore: this.target._transitionWeightCurrent,\r\n            _transitionWeightCurrent: 0,\r\n          })\r\n          .to({\r\n            _transitionWeightBefore: 0,\r\n            _transitionWeightCurrent: 1,\r\n          }, duration)\r\n          .call(() => {\r\n            if (this._beforeAction) {\r\n              this._beforeAction.stop();\r\n              this._beforeAction = null;\r\n            }\r\n          });\r\n      } else {\r\n        this.target._transitionWeightBefore = 0;\r\n        this.target._transitionWeightCurrent = 1;\r\n        if (this._beforeAction) {\r\n          this._beforeAction.stop();\r\n          this._beforeAction = null;\r\n        }\r\n      }\r\n\r\n      if (this._beforeMotion) this._beforeMotion.flare(\"exited\");\r\n      newMotion.flare(\"entered\");\r\n    },\r\n\r\n    setTime: function(time) {\r\n      this.target.$t.mixer.time = 0;\r\n      this.target.$t.mixer.update(time);\r\n      return this;\r\n    },\r\n\r\n    update: function(app) {\r\n      const target = this.target;\r\n\r\n      if (this._beforeAction) this._beforeAction.setEffectiveWeight(target._transitionWeightBefore);\r\n      if (this._currentAction) this._currentAction.setEffectiveWeight(target._transitionWeightCurrent);\r\n\r\n      if (this._currentMotion) this._currentMotion.update(this);\r\n\r\n      target.$t.mixer.update(app.deltaTime / 1000);\r\n    },\r\n\r\n  });\r\n\r\n  phina.define(\"phina.three.Motion\", {\r\n    superClass: \"phina.util.EventDispatcher\",\r\n\r\n    _transitions: null,\r\n    loop: false,\r\n\r\n    _clip: null,\r\n    _action: null,\r\n\r\n    _timeEventListeners: null,\r\n\r\n    init: function(clip) {\r\n      this.superInit();\r\n\r\n      this._clip = clip\r\n      this._transitions = [];\r\n\r\n      this._timeEventListeners = [];\r\n\r\n      this.on(\"entered\", e => {\r\n        this._timeEventListeners.forEach(t => {\r\n          t.fired = false;\r\n        });\r\n      });\r\n    },\r\n\r\n    /**\r\n     * pattern1:\r\n     *   addTransition(confitionObject, conditionProperty, nextMotion, duration)\r\n     *\r\n     * pattern2:\r\n     *   addTransition(conditionExpression, nextMotion, duration)\r\n     *\r\n     * pattern3:\r\n     *   addTransition(eventName, nextMotion, duration)\r\n     *\r\n     */\r\n    addTransition: function(condition, motion, duration) {\r\n      if (arguments.length == 4) {\r\n        const object = arguments[0];\r\n        const property = arguments[1];\r\n        motion = arguments[2];\r\n        duration = arguments[3];\r\n\r\n        this._transitions.push({\r\n          condition: () => object[property],\r\n          motion: motion,\r\n          duration: duration || 1,\r\n        });\r\n      } else {\r\n        if (typeof(condition) == \"function\") {\r\n          this._transitions.push({\r\n            condition: condition,\r\n            motion: motion,\r\n            duration: duration || 1,\r\n          });\r\n        } else if (typeof(condition) == \"string\") {\r\n          const flag = false;\r\n          this.on(\"entered\", () => flag = false);\r\n          this.on(condition, () => flag = true);\r\n          this._transitions.push({\r\n            condition: () => flag,\r\n            motion: motion,\r\n            duration: duration || 0,\r\n          });\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    addTimeEventListener: function(time, listener) {\r\n      this._timeEventListeners.push({\r\n        time: time,\r\n        listener: listener,\r\n        fired: false,\r\n      });\r\n      return this;\r\n    },\r\n\r\n    at: function(time, listener) {\r\n      return this.addTimeEventListener(time, listener);\r\n    },\r\n\r\n    update: function(controller) {\r\n      if (this._action) {\r\n        this._timeEventListeners.forEach(t => {\r\n          if (!t.fired && t.time <= this._action.time * 1000) {\r\n            t.listener.apply(this);\r\n            t.fired = true;\r\n          }\r\n        });\r\n      }\r\n\r\n      this._transitions.forEach(t => {\r\n        if (t.condition()) {\r\n          controller.switchMotion(t.motion, t.duration);\r\n          return;\r\n        }\r\n      });\r\n    },\r\n\r\n    setLoop: function(loop) {\r\n      this.loop = loop;\r\n      return this;\r\n    },\r\n\r\n  });\r\n\r\n});","phina.namespace(function() {\r\n\r\n  phina.define(\"phina.three.Object3D\", {\r\n    superClass: \"phina.app.Element\",\r\n\r\n    $t: null,\r\n\r\n    init: function(options) {\r\n      this.superInit();\r\n      options = ({}).$safe(options, {\r\n        position: new THREE.Vector3(),\r\n        scale: new THREE.Vector3(1, 1, 1),\r\n        rotation: new THREE.Euler(),\r\n        visible: true,\r\n      });\r\n\r\n      this.$t = options.$t;\r\n\r\n      this.position.copy(options.position);\r\n      this.scale.copy(options.scale);\r\n      this.rotation.copy(options.rotation);\r\n      this.visible = options.visible;\r\n      this._position2d = new THREE.Vector2();\r\n    },\r\n\r\n    setPosition: function(x, y, z) {\r\n      this.position.set(x, y, z);\r\n      return this;\r\n    },\r\n\r\n    setScale: function(sx, sy, sz) {\r\n      sy = (sy !== undefined) ? sy : sx;\r\n      sz = (sz !== undefined) ? sz : sx;\r\n      this.scale.set(sx, sy, sz);\r\n      return this;\r\n    },\r\n\r\n    setRotationX: function(v) {\r\n      this.rotationX = v;\r\n      return this;\r\n    },\r\n    setRotationY: function(v) {\r\n      this.rotationY = v;\r\n      return this;\r\n    },\r\n    setRotationZ: function(v) {\r\n      this.rotationZ = v;\r\n      return this;\r\n    },\r\n\r\n    _accessor: {\r\n      position2d: {\r\n        get: function() {\r\n          this._position2d.x = this.$t.position.x;\r\n          this._position2d.y = this.$t.position.z;\r\n          return this._position2d;\r\n        },\r\n      },\r\n      position: {\r\n        get: function() {\r\n          return this.$t.position;\r\n        },\r\n      },\r\n      scale: {\r\n        get: function() {\r\n          return this.$t.scale;\r\n        },\r\n      },\r\n      rotation: {\r\n        get: function() {\r\n          return this.$t.rotation;\r\n        },\r\n      },\r\n      quaternion: {\r\n        get: function() {\r\n          return this.$t.quaternion;\r\n        },\r\n      },\r\n      matrix: {\r\n        get: function() {\r\n          return this.$t.matrix;\r\n        },\r\n      },\r\n      x: {\r\n        get: function() {\r\n          return this.$t.position.x;\r\n        },\r\n        set: function(v) {\r\n          this.$t.position.x = v;\r\n        },\r\n      },\r\n      y: {\r\n        get: function() {\r\n          return this.$t.position.y;\r\n        },\r\n        set: function(v) {\r\n          this.$t.position.y = v;\r\n        },\r\n      },\r\n      z: {\r\n        get: function() {\r\n          return this.$t.position.z;\r\n        },\r\n        set: function(v) {\r\n          this.$t.position.z = v;\r\n        },\r\n      },\r\n      scaleX: {\r\n        get: function() {\r\n          return this.$t.scale.x;\r\n        },\r\n        set: function(v) {\r\n          this.$t.scale.x = v;\r\n        },\r\n      },\r\n      scaleY: {\r\n        get: function() {\r\n          return this.$t.scale.y;\r\n        },\r\n        set: function(v) {\r\n          this.$t.scale.y = v;\r\n        },\r\n      },\r\n      scaleZ: {\r\n        get: function() {\r\n          return this.$t.scale.z;\r\n        },\r\n        set: function(v) {\r\n          this.$t.scale.z = v;\r\n        },\r\n      },\r\n      rotationX: {\r\n        get: function() {\r\n          return this.$t.rotation.x;\r\n        },\r\n        set: function(v) {\r\n          this.$t.rotation.x = v;\r\n        },\r\n      },\r\n      rotationY: {\r\n        get: function() {\r\n          return this.$t.rotation.y;\r\n        },\r\n        set: function(v) {\r\n          this.$t.rotation.y = v;\r\n        },\r\n      },\r\n      rotationZ: {\r\n        get: function() {\r\n          return this.$t.rotation.z;\r\n        },\r\n        set: function(v) {\r\n          this.$t.rotation.z = v;\r\n        },\r\n      },\r\n      visible: {\r\n        get: function() {\r\n          return this.$t.visible;\r\n        },\r\n        set: function(v) {\r\n          this.$t.visible = v;\r\n        },\r\n      },\r\n    },\r\n\r\n  });\r\n\r\n});","phina.namespace(function() {\r\n\r\n\r\n  phina.define(\"phina.three.SkinnedMesh\", {\r\n    superClass: \"phina.three.Mesh\",\r\n\r\n    _motionCache: null,\r\n    centerPosition: null,\r\n\r\n    init: function(options) {\r\n      if (typeof(options.$t) == \"string\") {\r\n        this.assetName = options.$t;\r\n        options.$t = phina.asset.AssetManager.get(\"skinned\", this.assetName).clone();\r\n      }\r\n\r\n      this.superInit(options);\r\n\r\n      this.$t.mixer = new THREE.AnimationMixer(this.$t);\r\n      this._motionCache = {};\r\n    },\r\n\r\n    createMotion: function(indexOrName) {\r\n      let clip = typeof(indexOrName) == \"number\" ? this.$t.geometry.animations[indexOrName] : THREE.AnimationClip.findByName(this.$t, indexOrName);\r\n      return Motion(clip);\r\n    },\r\n\r\n    getMotion: function(indexOrName) {\r\n      if (this._motionCache[indexOrName] == null) {\r\n        let clip = typeof(indexOrName) == \"number\" ? this.$t.geometry.animations[indexOrName] : THREE.AnimationClip.findByName(this.$t, indexOrName);\r\n        this._motionCache[indexOrName] = Motion(clip);\r\n      }\r\n      return this._motionCache[indexOrName];\r\n    },\r\n\r\n    playDefaultMotion: function(name) {\r\n      const motion = name ? this.getMotion(name).setLoop(true) : this.getMotion(0).setLoop(true);\r\n      this.motionController.switchMotion(motion);\r\n    },\r\n\r\n    _accessor: {\r\n      motionController: {\r\n        get: function() {\r\n          if (this._motionController == null) {\r\n            this._motionController = phina.three.MotionController().attachTo(this);\r\n          }\r\n          return this._motionController;\r\n        },\r\n      },\r\n    },\r\n\r\n  });\r\n\r\n  phina.define(\"phina.three.SkinnedAsset\", {\r\n    superClass: \"phina.asset.Asset\",\r\n\r\n    init: function() {\r\n      this.superInit();\r\n    },\r\n\r\n    _load: function(resolve) {\r\n      const url = this.src;\r\n\r\n      const loader = new THREE.ObjectLoader();\r\n      loader.load(url, (loaded) => {\r\n        loaded.traverse((child) => {\r\n          if (child instanceof THREE.SkinnedMesh) {\r\n            resolve(child);\r\n          }\r\n        });\r\n      });\r\n    },\r\n  });\r\n  phina.asset.AssetLoader.register(\"skinned\", (key, src) => phina.three.SkinnedAsset().load(src));\r\n\r\n});"]}